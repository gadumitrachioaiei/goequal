package equal

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"testing"
)

var generatedHeader = `// Code generated by goequal for type: %s; DO NOT EDIT
package test
`

type Golden struct {
	name   string // for debugging only
	input  string // input for the generator
	output string // what output for the generator should be
}

var golden = []Golden{
	{"pointerVar", pointerVarIn, pointerVarOut},
	{"pointerVarComplex", pointerVarComplexIn, pointerVarComplexOut},
	{"pointerVarComplex2", pointerVarComplex2In, pointerVarComplex2Out},
	{"pointerVarNamed", pointerVarNamedIn, pointerVarNamedOut},
	{"pointerType", pointerTypeIn, pointerTypeOut},

	{"mapVar", mapVarIn, mapVarOut},
	{"mapVarComplex", mapVarComplexIn, mapVarComplexOut},
	{"mapVarNamed", mapVarNamedIn, mapVarNamedOut},
	{"mapType", mapTypeIn, mapTypeOut},

	{"sliceVar", sliceVarIn, sliceVarOut},
	{"sliceVarComplex", sliceVarComplexIn, sliceVarComplexOut},
	{"sliceVarComplex2", sliceVarComplex2In, sliceVarComplex2Out},
	{"sliceVarNamed", sliceVarNamedIn, sliceVarNamedOut},
	{"sliceType", sliceTypeIn, sliceTypeOut},

	{"arrayVar", arrayVarIn, arrayVarOut},
	{"arrayVarComplex", arrayVarComplexIn, arrayVarComplexOut},
	{"arrayVarComplex2", arrayVarComplex2In, arrayVarComplex2Out},
	{"arrayVarNamed", arrayVarNamedIn, arrayVarNamedOut},
	{"arrayType", arrayTypeIn, arrayTypeOut},
	{"arrayType2", arrayType2In, arrayType2Out},
	{"arrayType3", arrayType3In, arrayType3Out},

	{"nonPointerType", nonPointerTypeIn, nonPointerTypeOut},
	{"dereferenceNamedType", dereferenceNamedTypeIn, dereferenceNamedTypeOut},
	{"addressNamedType", addressNamedTypeIn, addressNamedTypeOut},
	{"simple", simpleIn, simpleOut},
	{"embedded", embeddedIn, embeddedOut},

	{"interfaceVar", interfaceVarIn, interfaceVarOut},
	{"interfaceVar2", interfaceVar2In, interfaceVar2Out},
	{"interfaceVar3", interfaceVar3In, interfaceVar3Out},
	{"interfaceVar4", interfaceVar4In, interfaceVar4Out},
	{"interfaceVar5", interfaceVar5In, interfaceVar5Out},
	{"interfaceType", interfaceTypeIn, interfaceTypeOut},
	{"interfaceType2", interfaceType2In, interfaceType2Out},

	{"stdVar", stdVarIn, stdVarOut},
	{"stdVar2", stdVar2In, stdVar2Out},
	{"stdVar3", stdVar3In, stdVar3Out},
	{"stdVar4", stdVar4In, stdVar4Out},
	{"stdVar5", stdVar5In, stdVar5Out},

	{"chanVar", chanVarIn, chanVarOut},
	{"chanVar2", chanVar2In, chanVar2Out},
	{"chanType", chanTypeIn, chanTypeOut},

	{"funcVar", funcVarIn, funcVarOut},
	{"funcVar2", funcVar2In, funcVar2Out},
	{"funcType", funcTypeIn, funcTypeOut},

	{"treeVar", treeVarIn, treeVarOut},
}

// pointer variable
var pointerVarIn = `
package test
type Test struct {
	a *int
}`

var pointerVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if (*t1.a) != (*t2.a) {
			return false
		}
	}
	return true
}
`

// pointer variable complex
var pointerVarComplexIn = `
package test
type Test struct {
	a *[]*int
}
`

// range (*t1.a) is transformed by format to range *t1.a
var pointerVarComplexOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if len((*t1.a)) != len((*t2.a)) {
			return false
		}
		for i1 := range *t1.a {
			if (*t1.a)[i1] != (*t2.a)[i1] {
				if (*t1.a)[i1] == nil || (*t2.a)[i1] == nil {
					return false
				}
				if (*(*t1.a)[i1]) != (*(*t2.a)[i1]) {
					return false
				}
			}
		}
	}
	return true
}
`

// pointer variable complex 2
// TODO: big mistake here when we replace part of name with value11
// (*t1.a)[i1][key1] -> value11)
// getNames transforms:
// (*(*a)[i1][key1]) -> value11) value12)
var pointerVarComplex2In = `
package test
type Test struct {
	a *[]map[int]*int
}
`

var pointerVarComplex2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if len((*t1.a)) != len((*t2.a)) {
			return false
		}
		for i1 := range *t1.a {
			if len((*t1.a)[i1]) != len((*t2.a)[i1]) {
				return false
			}
			for key1, value11 := range (*t1.a)[i1] {
				if value12, ok := (*t2.a)[i1][key1]; !ok {
					return false
				} else {
					if value11 != value12 {
						if value11 == nil || value12 == nil {
							return false
						}
						if (*value11) != (*value12) {
							return false
						}
					}
				}
			}
		}
	}
	return true
}
`

// pointer variable to named type
var pointerVarNamedIn = `
package test
type Test2 struct {
	a int
}
type Test struct {
	a *Test2
}
`

var pointerVarNamedOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !EqualTest2(t1.a, t2.a) {
		return false
	}
	return true
}
`

// pointer type
var pointerTypeIn = `
package test
type Test *int
`

var pointerTypeOut = `
func EqualTest(t1, t2 Test) bool {
	if t1 != t2 {
		if t1 == nil || t2 == nil {
			return false
		}
		if (*t1) != (*t2) {
			return false
		}
	}
	return true
}
`

// map as variable
var mapVarIn = `
package test
type Test struct {
	a map[string]int
}
`

var mapVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for key1, value11 := range t1.a {
		if value12, ok := t2.a[key1]; !ok {
			return false
		} else {
			if value11 != value12 {
				return false
			}
		}
	}
	return true
}
`

// map variable complex
var mapVarComplexIn = `
package test
type Test struct {
	a map[int][]map[int]int
}
`
var mapVarComplexOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for key1, value11 := range t1.a {
		if value12, ok := t2.a[key1]; !ok {
			return false
		} else {
			if len(value11) != len(value12) {
				return false
			}
			for i1 := range value11 {
				if len(value11[i1]) != len(value12[i1]) {
					return false
				}
				for key2, value21 := range value11[i1] {
					if value22, ok := value12[i1][key2]; !ok {
						return false
					} else {
						if value21 != value22 {
							return false
						}
					}
				}
			}
		}
	}
	return true
}
`

// map var with named type values
var mapVarNamedIn = `
package test
type Test2 struct {
	a int
}
type Test struct {
	a map[int]*Test2
}
`

var mapVarNamedOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for key1, value11 := range t1.a {
		if value12, ok := t2.a[key1]; !ok {
			return false
		} else {
			if !EqualTest2(value11, value12) {
				return false
			}
		}
	}
	return true
}
`

// map as type
var mapTypeIn = `
package test
type Test map[string]int
`

var mapTypeOut = `
func EqualTest(t1, t2 Test) bool {
	if len(t1) != len(t2) {
		return false
	}
	for key1, value11 := range t1 {
		if value12, ok := t2[key1]; !ok {
			return false
		} else {
			if value11 != value12 {
				return false
			}
		}
	}
	return true
}
`

// var slice
var sliceVarIn = `
package test
type Test struct {
	a []int
	b []byte
}
`

var sliceVarOut = `
import "bytes"

func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for i1 := range t1.a {
		if t1.a[i1] != t2.a[i1] {
			return false
		}
	}
	if !bytes.Equal(t1.b, t2.b) {
		return false
	}
	return true
}
`

// slice var complex
var sliceVarComplexIn = `
package test
type Test struct {
	a []*[]int
}
`

var sliceVarComplexOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for i1 := range t1.a {
		if t1.a[i1] != t2.a[i1] {
			if t1.a[i1] == nil || t2.a[i1] == nil {
				return false
			}
			if len((*t1.a[i1])) != len((*t2.a[i1])) {
				return false
			}
			for i2 := range *t1.a[i1] {
				if (*t1.a[i1])[i2] != (*t2.a[i1])[i2] {
					return false
				}
			}
		}
	}
	return true
}
`

// slice var complex
var sliceVarComplex2In = `
package test
type Test struct {
	a []*[]map[int]int
}
`

var sliceVarComplex2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for i1 := range t1.a {
		if t1.a[i1] != t2.a[i1] {
			if t1.a[i1] == nil || t2.a[i1] == nil {
				return false
			}
			if len((*t1.a[i1])) != len((*t2.a[i1])) {
				return false
			}
			for i2 := range *t1.a[i1] {
				if len((*t1.a[i1])[i2]) != len((*t2.a[i1])[i2]) {
					return false
				}
				for key1, value11 := range (*t1.a[i1])[i2] {
					if value12, ok := (*t2.a[i1])[i2][key1]; !ok {
						return false
					} else {
						if value11 != value12 {
							return false
						}
					}
				}
			}
		}
	}
	return true
}
`

// slice var named
var sliceVarNamedIn = `
package test
type Test2 int
type Test struct {
	a []Test2
}
`

var sliceVarNamedOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for i1 := range t1.a {
		if !EqualTest2(t1.a[i1], t2.a[i1]) {
			return false
		}
	}
	return true
}
`

// slice type
var sliceTypeIn = `
package test
type Test []int
`

var sliceTypeOut = `
func EqualTest(t1, t2 Test) bool {
	if len(t1) != len(t2) {
		return false
	}
	for i1 := range t1 {
		if t1[i1] != t2[i1] {
			return false
		}
	}
	return true
}
`

// array var
var arrayVarIn = `
package test
type Test struct {
	a [2]int
}
`

var arrayVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		return false
	}
	return true
}
`

// array var complex
var arrayVarComplexIn = `package test
type Test struct {
	a [1]*[2]int
}
`

var arrayVarComplexOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	for i1 := range t1.a {
		if t1.a[i1] != t2.a[i1] {
			if t1.a[i1] == nil || t2.a[i1] == nil {
				return false
			}
			if (*t1.a[i1]) != (*t2.a[i1]) {
				return false
			}
		}
	}
	return true
}
`

// array var complex 2
var arrayVarComplex2In = `
package test
type Test struct {
	a [1]*[2]map[int]int
}
`

var arrayVarComplex2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	for i1 := range t1.a {
		if t1.a[i1] != t2.a[i1] {
			if t1.a[i1] == nil || t2.a[i1] == nil {
				return false
			}
			for i2 := range *t1.a[i1] {
				if len((*t1.a[i1])[i2]) != len((*t2.a[i1])[i2]) {
					return false
				}
				for key1, value11 := range (*t1.a[i1])[i2] {
					if value12, ok := (*t2.a[i1])[i2][key1]; !ok {
						return false
					} else {
						if value11 != value12 {
							return false
						}
					}
				}
			}
		}
	}
	return true
}
`

// array var named
var arrayVarNamedIn = `
package test
type Test2 int
type Test struct {
	a [1]Test2
}
`

var arrayVarNamedOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	for i1 := range t1.a {
		if !EqualTest2(t1.a[i1], t2.a[i1]) {
			return false
		}
	}
	return true
}
`

// array type
var arrayTypeIn = `
package test
type Test [2]int
`

var arrayTypeOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if (*t1) != (*t2) {
		return false
	}
	return true
}
`

// array type
var arrayType2In = `
package test
type Test *[2]int
`

var arrayType2Out = `
func EqualTest(t1, t2 Test) bool {
	if t1 != t2 {
		if t1 == nil || t2 == nil {
			return false
		}
		if (*t1) != (*t2) {
			return false
		}
	}
	return true
}
`

// array type
var arrayType3In = `
package test
type Test [2]map[int]int
`

var arrayType3Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	for i1 := range *t1 {
		if len((*t1)[i1]) != len((*t2)[i1]) {
			return false
		}
		for key1, value11 := range (*t1)[i1] {
			if value12, ok := (*t2)[i1][key1]; !ok {
				return false
			} else {
				if value11 != value12 {
					return false
				}
			}
		}
	}
	return true
}
`

// non pointer type
var nonPointerTypeIn = `
package test
type Test struct {
	a int
}
`

var nonPointerTypeOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		return false
	}
	return true
}
`

// test that we dereference a var pointing to named type
// fix bug
var dereferenceNamedTypeIn = `
package test
type Test2 int
type Test struct {
	a *Test2
}
`

var dereferenceNamedTypeOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if !EqualTest2((*t1.a), (*t2.a)) {
			return false
		}
	}
	return true
}
`

// test that use take the address of a var to a named type
var addressNamedTypeIn = `
package test
type Test2 struct {
	a int
}
type Test struct {
	a Test2
}
`

var addressNamedTypeOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !EqualTest2((&t1.a), (&t2.a)) {
		return false
	}
	return true
}
`

var simpleIn = `
package test
type Test int
`

var simpleOut = `
func EqualTest(t1, t2 Test) bool {
	if t1 != t2 {
		return false
	}
	return true
}
`

// embedded
var embeddedIn = `
package test
type Test2 struct {
	a int
}
type Test struct {
	Test2
	a int
}
`

var embeddedOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !EqualTest2((&t1.Test2), (&t2.Test2)) {
		return false
	}
	if t1.a != t2.a {
		return false
	}
	return true
}
`

// complex stuff
var complexIn = `
package test
type Test2 struct {
	int
}
type Test struct {
	a *[]map[int]*[]map[int]Test2
}
`

var complexOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if len((*t1.a)) != len((*t2.a)) {
			return false
		}
		for i1 := range *t1.a {
			if len((*t1.a)[i1]) != len((*t2.a)[i1]) {
				return false
			}
			for key1, value11 := range (*t1.a)[i1] {
				if value12, ok := (*t2.a)[i1][key1]; !ok {
					return false
				} else {
					if value11 != value12 {
						if value11 == nil || value12 == nil {
							return false
						}
						if len((*value11)) != len((*value12)) {
							return false
						}
						for i2 := range *value11 {
							if len((*value11)[i2]) != len((*value12)[i2]) {
								return false
							}
							for key2, value21 := range (*value11)[i2] {
								if value22, ok := (*value12)[i2][key2]; !ok {
									return false
								} else {
									if !EqualTest2((&value21), (&value22)) {
										return false
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return true
}
`

// var interface
var interfaceVarIn = `
package test
type Test struct {
	a interface{}
}
`

var interfaceVarOut = `
import "reflect"

func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !reflect.DeepEqual(t1.a, t2.a) {
		return false
	}
	return true
}
`

// var interface
var interfaceVar2In = `
package test
type Test2 interface {
	Read() int
}
type Test struct {
	a Test2
}
`

var interfaceVar2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !EqualTest2(t1.a, t2.a) {
		return false
	}
	return true
}
`

// var interface
var interfaceVar3In = `
package test
type Test struct {
	a []interface{}
}
`

var interfaceVar3Out = `
import "reflect"

func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for i1 := range t1.a {
		if !reflect.DeepEqual(t1.a[i1], t2.a[i1]) {
			return false
		}
	}
	return true
}
`

// var interface
var interfaceVar4In = `
package test
type Test struct {
	a [2]interface{}
}
`

var interfaceVar4Out = `
import "reflect"

func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	for i1 := range t1.a {
		if !reflect.DeepEqual(t1.a[i1], t2.a[i1]) {
			return false
		}
	}
	return true
}
`

// var interface
var interfaceVar5In = `
package test
type Test struct {
	a map[int]interface{}
}
`

var interfaceVar5Out = `
import "reflect"

func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for key1, value11 := range t1.a {
		if value12, ok := t2.a[key1]; !ok {
			return false
		} else {
			if !reflect.DeepEqual(value11, value12) {
				return false
			}
		}
	}
	return true
}
`

// interface type
var interfaceTypeIn = `
package test
type Test interface{}
`

var interfaceTypeOut = `
import "reflect"

func EqualTest(t1, t2 Test) bool {
	if !reflect.DeepEqual(t1, t2) {
		return false
	}
	return true
}
`

// interface type 2
var interfaceType2In = `
package test
type Test []interface{}
`

var interfaceType2Out = `
import "reflect"

func EqualTest(t1, t2 Test) bool {
	if len(t1) != len(t2) {
		return false
	}
	for i1 := range t1 {
		if !reflect.DeepEqual(t1[i1], t2[i1]) {
			return false
		}
	}
	return true
}
`

// std var
var stdVarIn = `
package test
import "sync"
type Test struct {
	b sync.Mutex
}
`
var stdVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	return true
}
`

// std var 2
var stdVar2In = `
package test
import "sync/atomic"
type Test struct {
	b []atomic.Value
}
`
var stdVar2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.b) != len(t2.b) {
		return false
	}
	return true
}
`

// std var 3
var stdVar3In = `
package test
import "sync/atomic"
type Test struct {
	b [2]atomic.Value
}
`
var stdVar3Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	return true
}
`

// std var 4
var stdVar4In = `
package test
import "sync/atomic"
type Test struct {
	b map[int]atomic.Value
}
`
var stdVar4Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.b) != len(t2.b) {
		return false
	}
	for key1 := range t1.b {
		if _, ok := t2.b[key1]; !ok {
			return false
		}
	}
	return true
}
`

// std var 5
var stdVar5In = `
package test
import "sync/atomic"
type Test struct {
	b *atomic.Value
}
`
var stdVar5Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.b != t2.b {
		if t1.b == nil || t2.b == nil {
			return false
		}
	}
	return true
}
`

// chan var
var chanVarIn = `
package test
type Test struct {
	c chan string 
}
`

var chanVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	return true
}
`

// chan var 2
var chanVar2In = `
package test
type Test struct {
	a []chan string 
}
`

var chanVar2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	return true
}
`

// chan type
var chanTypeIn = `
package test
type Test chan int
`

var chanTypeOut = `
func EqualTest(t1, t2 Test) bool {
	return true
}
`

// func var
var funcVarIn = `
package test
type Test struct {
	a func() 
}
`
var funcVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	return true
}
`

// func var 2
var funcVar2In = `
package test
type Test struct {
	a map[int]func() 
}
`
var funcVar2Out = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if len(t1.a) != len(t2.a) {
		return false
	}
	for key1 := range t1.a {
		if _, ok := t2.a[key1]; !ok {
			return false
		}
	}
	return true
}
`

// func type
var funcTypeIn = `
package test
type Test chan int
`

var funcTypeOut = `
func EqualTest(t1, t2 Test) bool {
	return true
}
`

// tree var
var treeVarIn = `
package test
type Test struct {
	a string
	t1 *Test
}
`
var treeVarOut = `
func EqualTest(t1, t2 *Test) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		return false
	}
	if !EqualTest(t1.t1, t2.t1) {
		return false
	}
	return true
}
`

// TestGolden tests generated code for types that don't refer to other named types
func TestGolden(t *testing.T) {
	typ, pkgPath := "Test", "test"
	for _, test := range golden {
		input := map[string]interface{}{pkgPath: test.input}
		g := NewGenerator(pkgPath, typ, false, input)
		g.parse()
		expectedType := Type{typ, pkgPath}
		code := g.equals[expectedType]
		failed := false
		if code == nil {
			t.Errorf("expected code for type: %v", expectedType)
			failed = true
		} else {
			_, generatedCode := code.serialize()
			expectedCode := fmt.Sprintf(generatedHeader, typ) + test.output
			if expectedCode != string(generatedCode) {
				t.Errorf("test: %s, type: %v, expected:\n%s, found:\n%s", test.name, expectedType, expectedCode, string(generatedCode))
				failed = true
			}
		}
		// I will compile the generated code for extra checking
		if !failed || true {
			files := []string{"test.go"}
			inputs := []interface{}{test.input}
			counter := 0
			for _, code := range g.equals {
				counter++
				files = append(files, fmt.Sprintf("f%d.go", counter))
				_, generatedCode := code.serialize()
				inputs = append(inputs, string(generatedCode))
			}
			if err := compile(files, inputs); err != nil {
				t.Errorf("test: %s, code not compilable: %s", test.name, err)
			}
		}
	}
}

// TestGetNames tests getNames
func TestGetNames(t *testing.T) {
	names := []struct {
		name         string
		isType       bool
		name1, name2 string
	}{
		{"a", false, "t1.a", "t2.a"},
		{"a1", false, "t1.a1", "t2.a1"},
		{"A", true, "t1", "t2"},
		{"A1", true, "t1", "t2"},
		{"a[i1]", false, "t1.a[i1]", "t2.a[i1]"},
		{"aţăb[i1]", false, "t1.aţăb[i1]", "t2.aţăb[i1]"},
		{"(*(*a)[i1])[i2]", false, "(*(*t1.a)[i1])[i2]", "(*(*t2.a)[i1])[i2]"},
		{"a[i1][key1]", false, "value11", "value12"},
		{"a[i1][key1][key2]", false, "value21", "value22"},
		{"(*a[i1])[key1]", false, "value11", "value12"},
		{"(*a[i1][key1])[i2]", false, "(*value11)[i2]", "(*value12)[i2]"},
		{"(*aţăb[i1][key1])[i2]", false, "(*value11)[i2]", "(*value12)[i2]"},
	}
	for _, test := range names {
		name1, name2 := getNames(test.name, test.isType)
		if test.name1 != name1 || test.name2 != name2 {
			t.Errorf("expected names:\n%s %s\nfound:\n%s %s\n", test.name1, test.name2, name1, name2)
		}
	}
}

// TestFindNextUsableIndex
func TestFindNextUsableIndex(t *testing.T) {
	names := []struct {
		name  string
		key   string
		index int
	}{
		{"a", "i", 1},
		{"a1[i1]", "i", 2},
		{"a[i12]", "i", 13},
		{"A[i1]", "i", 2},
		{"aţăb[i1]", "i", 2},
		{"(*(*a)[i1])[i2]", "i", 3},
	}
	for _, test := range names {
		index := findNextUsableIndex(test.name, test.key)
		if test.index != index {
			t.Errorf("expected index: %d\nfound: %d\n", test.index, index)
		}
	}
}

// compile compiles the specified go code
func compile(files []string, inputs []interface{}) error {
	var astFiles []*ast.File
	fs := token.NewFileSet()
	for i, file := range files {
		parsedFile, err := parser.ParseFile(fs, file, inputs[i], 0)
		if err != nil {
			return err
		}
		astFiles = append(astFiles, parsedFile)
	}
	config := types.Config{Importer: importer.Default(), FakeImportC: true}
	_, err := config.Check(`main`, fs, astFiles, nil)
	if err != nil {
		return err
	}
	return nil
}
