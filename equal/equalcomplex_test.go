package equal

import (
	"fmt"
	"testing"
)

type GoldenComplex struct {
	name    string                 // for debgugging only
	typ     string                 // name of main type
	pkgPath string                 // package path of main type
	input   map[string]interface{} // input for the generator
	output  map[Type]string        // what output for the generator should be
}

var goldenC = []GoldenComplex{
	{"followType", "X", "test", followTypeIn, followTypeOut},
}

// follow type
var followTypeIn = map[string]interface{}{
	`test`: `package test
type X struct {
	a *int
	b Y
}
type Y map[string]int
`,
}

var followTypeOut = map[Type]string{
	{"X", "test"}: `// Code generated by goequal for type: X; DO NOT EDIT
package test

func EqualX(t1, t2 *X) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.a != t2.a {
		if t1.a == nil || t2.a == nil {
			return false
		}
		if (*t1.a) != (*t2.a) {
			return false
		}
	}
	if !EqualY(t1.b, t2.b) {
		return false
	}
	return true
}
`,
	{"Y", "test"}: `// Code generated by goequal for type: Y; DO NOT EDIT
package test

func EqualY(t1, t2 Y) bool {
	if len(t1) != len(t2) {
		return false
	}
	for key1, value11 := range t1 {
		if value12, ok := t2[key1]; !ok {
			return false
		} else {
			if value11 != value12 {
				return false
			}
		}
	}
	return true
}
`,
}

// TestGoldenC tests generated code for types that refer to other named types
func TestGoldenC(t *testing.T) {
	for _, test := range goldenC {
		// I will compile the generated code for extra checking
		g := NewGenerator(test.pkgPath, test.typ, false, test.input)
		g.parse()
		success, files, inputs := assertComplex(t, g, test)
		if success {
			files = append(files, "test.go")
			inputs = append(inputs, test.input[test.pkgPath])
			if err := compile(files, inputs); err != nil {
				t.Errorf("test: %s, code not compilable: %s", test.name, err)
			}
		}

	}
}

// assertComplex asserts that a complex test passes
// returns success, list of files and their containing code
func assertComplex(t *testing.T, g *Generator, test GoldenComplex) (success bool, files []string, inputs []interface{}) {
	success = true
	counter := 0
	for expectedType, expectedCode := range test.output {
		code := g.equals[expectedType]
		if code == nil {
			t.Errorf("expected code for type: %v", expectedType)
			success = false
		} else {
			_, calculatedCode := code.serialize()
			if expectedCode != string(calculatedCode) {
				t.Errorf("test: %s, type: %v, expected: \n%s, found: \n%s", test.name, expectedType, expectedCode, string(calculatedCode))
				success = false
			} else {
				// add to compilable code
				counter++
				files = append(files, fmt.Sprintf("f%d.go", counter))
				inputs = append(inputs, expectedCode)
			}
		}
	}
	return
}
