package equal

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/gadumitrachioaiei/goequal/equal/testdata"
)

// GOPATH should consist of only one folder
var GOPATH = os.Getenv("GOPATH")

var goldenD = []GoldenComplex{
	{"packages", "X", "test", packagesIn, packagesOut},
	{"alias", "X", "test", aliasIn, aliasOut},
	{"dotImport", "X", "test", dotImportIn, dotImportOut},
	{"cgo", "X", "test", cgoIn, cgoOut},
}

// types in multiple packages
var packagesIn = map[string]interface{}{
	`test`: `package test
import "test2"
type X struct {
	b test2.Y
}
`,
	`test2`: `package test2
type Y int
`,
}

var packagesOut = map[Type]string{
	{"X", "test"}: `// Code generated by goequal for type: X; DO NOT EDIT
package test

import "test2"

func EqualX(t1, t2 *X) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !test2.EqualY(t1.b, t2.b) {
		return false
	}
	return true
}
`,
	{"Y", "test2"}: `// Code generated by goequal for type: Y; DO NOT EDIT
package test2

func EqualY(t1, t2 Y) bool {
	if t1 != t2 {
		return false
	}
	return true
}
`,
}

// type with alias import
var aliasIn = map[string]interface{}{
	`test`: `package test
import alias "test2"
type X struct {
	b alias.Y
}
`,
	`test2`: `package test2
type Y int
`,
}

var aliasOut = map[Type]string{
	{"X", "test"}: `// Code generated by goequal for type: X; DO NOT EDIT
package test

import alias "test2"

func EqualX(t1, t2 *X) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !alias.EqualY(t1.b, t2.b) {
		return false
	}
	return true
}
`,
	{"Y", "test2"}: `// Code generated by goequal for type: Y; DO NOT EDIT
package test2

func EqualY(t1, t2 Y) bool {
	if t1 != t2 {
		return false
	}
	return true
}
`,
}

// type with dot import
var dotImportIn = map[string]interface{}{
	`test`: `package test
import . "test2"
type X struct {
	b Y
}
`,
	`test2`: `package test2
type Y int
`,
}

var dotImportOut = map[Type]string{
	{"X", "test"}: `// Code generated by goequal for type: X; DO NOT EDIT
package test

import . "test2"

func EqualX(t1, t2 *X) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !EqualY(t1.b, t2.b) {
		return false
	}
	return true
}
`,
	{"Y", "test2"}: `// Code generated by goequal for type: Y; DO NOT EDIT
package test2

func EqualY(t1, t2 Y) bool {
	if t1 != t2 {
		return false
	}
	return true
}
`,
}

// cgo
var cgoIn = map[string]interface{}{
	`test`: `package test
/*
#include <stdlib.h>
*/
import "C"

import "test2"
func Seed(i int) {
    C.srandom(C.uint(i))
}

type X struct {
	a test2.Y
}
`,

	`test2`: `package test2
type Y int
`,
}

var cgoOut = map[Type]string{
	{"X", "test"}: `// Code generated by goequal for type: X; DO NOT EDIT
package test

import "test2"

func EqualX(t1, t2 *X) bool {
	if t1 == t2 {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if !test2.EqualY(t1.a, t2.a) {
		return false
	}
	return true
}
`,
}

// TestGoldenD tests generated code written to disk
// if the test fails you have to run the test again for cleanup or manually remove the test and test2 directories
func TestGoldenD(t *testing.T) {
	t.Skip("Skip test that writes to disk")
	for _, test := range goldenD {
		// write to disk
		if GOPATH == "" {
			t.Fatalf("No GOPATH")
		}
		failed := false
		names := []string{"test", "test2"}
		pkgPaths := []string{filepath.Join(GOPATH, "src", "test"), filepath.Join(GOPATH, "src", "test2")}
		// write the code to disk
		for i, pkgPath := range pkgPaths {
			if _, err := os.Stat(pkgPath); err == nil {
				t.Errorf("path: %s exists", pkgPath)
				failed = true
				break
			} else {
				if !os.IsNotExist(err) {
					t.Errorf("path: %s could not be asserted: %s", pkgPath, err)
					failed = true
					break
				}
			}
			if err := os.Mkdir(pkgPath, 0750); err != nil {
				t.Errorf("Can not create dir: %s %s", pkgPath, err)
				failed = true
				break
			}
			filePath := filepath.Join(pkgPath, "test.go")
			content := []byte(test.input[names[i]].(string))
			if err := ioutil.WriteFile(filePath, content, 0750); err != nil {
				t.Errorf("Can not create file:%s %s", filePath, err)
				failed = true
				break
			}
		}
		if failed {
			removePackages(t, pkgPaths)
			return
		}
		// first we need to install test package: https://github.com/golang/go/issues/14496
		if err := exec.Command("go", "install", "test").Run(); err != nil {
			t.Errorf("can not install package test: %s", err)
			removePackages(t, pkgPaths)
			return
		}
		// call the generator and assert
		g := NewGenerator(test.pkgPath, test.typ, false, nil)
		g.Generate()
		if assertDisk(t, g, test) {
			// compile the code
			for _, name := range names {
				if err := exec.Command("go", "build", name).Run(); err != nil {
					t.Errorf("Error compiling package: %s %s", name, err)
				}
			}
		}
		// remove the code from disk
		removePackages(t, pkgPaths)
	}
}

func removePackages(t *testing.T, pkgPaths []string) {
	for _, pkgPath := range pkgPaths {
		if err := os.RemoveAll(pkgPath); err != nil {
			t.Errorf("Can not delete dir: %s %s", pkgPath, err)
		}
	}
}

func assertDisk(t *testing.T, g *Generator, test GoldenComplex) bool {
	success := true
	for expectedType, expectedCode := range test.output {
		pkgPath := filepath.Join(GOPATH, "src", expectedType.pkgPath)
		expectedFile := filepath.Join(pkgPath, fmt.Sprintf("goequal_%s.go", expectedType.name))
		if content, err := ioutil.ReadFile(expectedFile); err != nil {
			t.Errorf("%s", err)
			success = false
		} else {
			if expectedCode != string(content) {
				t.Errorf("test: %s, type: %v, expected: \n%s, found: \n%s", test.name, expectedType, expectedCode, string(content))
				success = false
			}
		}
	}
	return success
}

// TestEquality tests generated function by calling on specific instances
func TestEquality(t *testing.T) {
	t.Skip("Skip test that writes to disk")
	g := NewGenerator("github.com/gadumitrachioaiei/goequal/equal/testdata", "X", false, nil)
	g.Generate()
	t1, t2 := &testdata.X{}, &testdata.X{}
	if !testdata.EqualX(t1, t2) {
		t.Fatal("Instances should be equal")
	}
	for i := 1; i < 18; i++ {
		switch i {
		case 1:
			t1.F1 = 1
		case 2:
			t1.F2 = "n"
		case 3:
			t1.F3 = []byte{'a', 'b', 'c'}
			t2.F3 = []byte{'a', 'd', 'c'}
		case 4:
			t1.F4 = []int{1, 2, 3}
			t2.F4 = []int{1, 3, 4}
		case 5:
			t1.F5 = [3]int{1, 2, 3}
			t2.F5 = [3]int{1, 3, 4}
		case 6:
			t1.F6 = map[int]int{1: 11, 2: 22}
			t2.F6 = map[int]int{1: 11, 3: 22}
		case 7:
			t1.F7 = map[int][]int{1: []int{1, 2, 3}, 2: []int{1, 2, 3}}
			t2.F7 = map[int][]int{1: []int{1, 2, 3}, 2: []int{1, 3, 3}}
		case 8:
			t1.F8 = []map[int]int{map[int]int{1: 2}, map[int]int{1: 2}, map[int]int{1: 2}}
			t2.F8 = []map[int]int{map[int]int{1: 2}, map[int]int{1: 3}, map[int]int{1: 2}}
		case 9:
			x, y := 1, 2
			t1.F9 = &x
			t2.F9 = &y
		case 10:
			t1.F10 = &[]int{1, 2, 3}
			t2.F10 = &[]int{1, 2, 4}
		case 11:
			t1.F11 = []map[int]*[]int{map[int]*[]int{1: &[]int{1, 2, 3}}}
			t2.F11 = []map[int]*[]int{map[int]*[]int{1: &[]int{1, 3, 3}}}
		case 12:
			t1.F12 = testdata.Y{1}
			t2.F12 = testdata.Y{2}
		case 13:
			t1.F13 = []*testdata.Y{&testdata.Y{1}, &testdata.Y{1}}
			t2.F13 = []*testdata.Y{&testdata.Y{2}, &testdata.Y{1}}
		case 14:
			t1.F14 = map[testdata.Y]int{testdata.Y{1}: 1, testdata.Y{2}: 2}
			t2.F14 = map[testdata.Y]int{testdata.Y{1}: 1, testdata.Y{2}: 3}
		case 15:
			t1.F15 = map[int]*testdata.Y{1: &testdata.Y{1}, 2: &testdata.Y{2}}
			t2.F15 = map[int]*testdata.Y{1: &testdata.Y{1}, 2: &testdata.Y{3}}
		case 16:
			t1.F16 = [][]int{[]int{1, 2, 3}, []int{1, 2, 3}}
			t2.F16 = [][]int{[]int{1, 2, 3}, []int{1, 2, 2}}
		case 17:
			t1.F17 = map[int]map[int]int{1: map[int]int{1: 2}}
			t2.F17 = map[int]map[int]int{1: map[int]int{1: 3}}
		}
		if testdata.EqualX(t1, t2) {
			t.Fatalf("Instances should be different because of F%d", i)
		}
		switch i {
		case 1:
			t2.F1 = t1.F1
		case 2:
			t2.F2 = t1.F2
		case 3:
			t2.F3 = t1.F3
		case 4:
			t2.F4 = t1.F4
		case 5:
			t2.F5 = t1.F5
		case 6:
			t2.F6 = t1.F6
		case 7:
			t2.F7 = t1.F7
		case 8:
			t2.F8 = t1.F8
		case 9:
			// we make two pointers to be equal
			t2.F9 = t1.F9
		case 10:
			t2.F10 = &[]int{1, 2, 3}
		case 11:
			t2.F11 = t1.F11
		case 12:
			t2.F12 = t1.F12
		case 13:
			t2.F13 = t1.F13
		case 14:
			t2.F14 = t1.F14
		case 15:
			t2.F15 = t1.F15
		case 16:
			t2.F16 = t1.F16
		case 17:
			t2.F17 = t1.F17
		}
		if !testdata.EqualX(t1, t2) {
			t.Fatalf("Instances should be equal at step: %d", i)
		}
	}
}
